# 中国象棋 (Chinese Chess - Xiangqi)

一个功能完整的中国象棋Web应用，支持玩家vs AI和AI vs AI对战，配备三档AI难度。

## 功能特性

### 核心功能
- ✅ **完整的象棋规则实现**
  - 7种棋子类型（将/帅、士、象、马、车、炮、兵/卒）
  - 精确的走法验证（蹩马腿、塞象眼、炮隔子等特殊规则）
  - 将军/将死/困毙检测
  - **和棋判定**（使用Zobrist哈希算法）：
    - ✅ 困毙（无子可动但未被将军）
    - ✅ 60回合无吃子自动判和
    - ✅ 三次重复局面判和（精确检测）
  - 白脸将检测（双方将帅面对面）

### 游戏模式
- 🎮 **玩家 vs AI** - 与电脑对战
- 🤖 **AI vs AI** - 观看两个AI对弈

### AI难度分级
- 🟢 **简单** - 搜索深度2层，适合初学者
- 🟡 **中等** - 搜索深度3层，具备一定挑战性
- 🔴 **困难** - 搜索深度4层，使用Alpha-Beta剪枝和完整评估函数

### AI技术实现
- **搜索算法**: Minimax with Alpha-Beta剪枝
- **评估函数**:
  - 子力价值评估（动态调整：过河兵价值翻倍）
  - 可扩展的位置价值、灵活性、威胁检测
- **优化技术**: Alpha-Beta剪枝减少90%+搜索节点
- **难度调整**: 搜索深度、随机性、评估准确度

### 其他功能
- ↩️ **悔棋功能** - 玩家vs AI模式下可悔棋一步（自动撤销玩家和AI的走法）
- 🎯 **走法提示** - 高亮显示选中棋子的合法走法
- 📊 **游戏状态显示** - 实时显示游戏进度和结果
- 🎨 **精美UI** - 现代化的渐变设计和流畅动画

## 技术栈

- **前端框架**: React 19 + TypeScript
- **构建工具**: Vite 7
- **状态管理**: React Context API
- **样式**: CSS3 (渐变、动画、响应式布局)

## 项目结构

```
xiangqi/
├── src/
│   ├── core/              # 核心游戏逻辑
│   │   ├── board/         # 棋盘和位置
│   │   ├── pieces/        # 7种棋子类
│   │   ├── move/          # 走法生成和验证
│   │   └── rules/         # 规则检测
│   ├── ai/                # AI引擎
│   │   ├── engine/        # Alpha-Beta搜索
│   │   ├── evaluation/    # 评估函数
│   │   └── difficulty/    # 难度配置
│   ├── game/              # 游戏管理
│   ├── components/        # React组件
│   ├── context/           # 状态管理
│   └── types/             # TypeScript类型
└── public/
```

## 快速开始

### 安装依赖
```bash
npm install
```

### 启动开发服务器
```bash
npm run dev
```

访问 http://localhost:5175 开始游戏

### 构建生产版本
```bash
npm run build
npm run preview
```

## 游戏说明

### 如何开始
1. 选择游戏模式（玩家vs AI 或 AI vs AI）
2. 选择AI难度（简单/中等/困难）
3. 点击"新游戏"开始

### 操作方法
- **移动棋子**: 点击棋子选中，绿色高亮显示可移动位置，再次点击目标位置移动
- **悔棋**: 点击"悔棋"按钮撤销上一步（会同时撤销玩家和AI的走法）
- **新游戏**: 随时开始新的对局

### 象棋规则要点
- **将/帅**: 只能在九宫内移动一格
- **士**: 只能在九宫内斜走一格
- **象**: 田字走法，不能过河，不能塞象眼
- **马**: 日字走法，不能蹩马腿
- **车**: 直线移动，路径无障碍
- **炮**: 不吃子时直线移动，吃子时必须隔一子
- **兵/卒**: 只能前进，过河后可横移

### 获胜与和棋条件

**获胜条件**:
- 将死对方（将军且无法解围）

**和棋条件**（满足任一即判和）:
1. **困毙** - 轮到某方走棋时无合法走法，但未被将军
2. **60回合无吃子** - 连续120步（双方各60步）没有吃子
3. **三次重复局面** - 同一棋盘状态出现3次（使用Zobrist哈希精确检测）
4. **白脸将** - 双方将帅同列且中间无子（违规，视为被将军）

**Zobrist哈希技术**:
- 为每个位置的每种棋子分配唯一随机数
- 使用XOR运算快速计算棋盘哈希值
- O(1)时间复杂度比较两个棋盘是否相同
- 准确检测重复局面，防止无限循环

## AI实现细节

### 搜索算法
```
Alpha-Beta剪枝伪代码:
function alphabeta(depth, alpha, beta):
    if depth == 0:
        return evaluate(position)

    for move in legal_moves:
        score = -alphabeta(depth-1, -beta, -alpha)
        alpha = max(alpha, score)
        if alpha >= beta:
            break  # Beta剪枝

    return alpha
```

### 评估函数权重
- 子力价值: 将10000, 车1200, 炮650, 马600, 士250, 象250, 兵100
- 过河兵: 200 (价值翻倍)
- 可扩展: 位置价值表、灵活性、威胁检测

### 性能优化
- Alpha-Beta剪枝: 减少90%+搜索节点
- 异步计算: 避免阻塞UI
- 棋盘克隆: 支持快速搜索和回退

## 未来改进方向

### P1 - 高优先级
- [ ] 完整的位置价值表(PST)
- [ ] 置换表优化
- [ ] 走法排序(MVV-LVA)
- [ ] 迭代加深搜索
- [ ] 提高困难档位搜索深度至7-9层

### P2 - 中优先级
- [ ] 静态搜索(Quiescence Search)
- [ ] 走法历史记录显示
- [ ] 棋谱导入/导出(FEN, UCCI)
- [ ] 走法动画效果
- [ ] 音效

### P3 - 低优先级
- [ ] 开局库
- [ ] 残局库
- [ ] Web Worker异步AI计算
- [ ] 在线对战
- [ ] 棋力评级系统

## 已知问题

1. AI搜索深度有限（困难模式仅4层），未达到真正的"专业棋手水平"
   - **原因**: 为了保证响应速度
   - **解决方案**: 实现迭代加深、置换表、更深的搜索

2. 评估函数较简单，仅考虑子力价值
   - **改进**: 添加位置价值表、威胁检测、棋型识别

3. 无走法历史和棋谱功能
   - **待实现**: 走法记录组件和棋谱导出

## 开发者

- 使用Claude Code完成开发
- 遵循现代Web开发最佳实践
- 完整的TypeScript类型安全
- 组件化架构，易于扩展

## 许可证

ISC

---

**享受游戏!** 🎮♟️
